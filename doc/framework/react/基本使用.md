# 基本使用

React是由facebook开发的用于构建用户界面的JavaScript库。

## 安装

react提供了三种安装方式。

1. 直接通过<script>标签引入react包。
2. 通过npm安装。
3. 使用create-react-app工具来构建一个基础的react开发环境。

## 组件

React的组件分为两种：**函数组件**和**类组件**。 

### 创建组件

#### 函数组件

函数组件是一个Javascript函数，它接受一个props对象作为参数。并返回一个react元素。这里的props对象包含了组件上定义的属性。

```jsx
// 定义了一个头像组件。组件名称开头字母必须大写，以区分html标签 
function Head(props) {    
    return (<div>             
        <img src="props.user.headUrl"></img>             
        <span>{props.user.userName}</span>            
        <div>); 
}  
```

#### 类组件

react还可以使用ES6的class定义组件,必须继承React.Component类。

```jsx
class head extends React.Component {  
    render() {    
        return <h1>hello, {props.user.userName}</h1>
    } 
}
```

React 元素是[不可变对象](https://en.wikipedia.org/wiki/Immutable_object)。一旦被创建，你就无法更改它的子元素或者属性。一个元素就像电影的单帧：它代表了某个特定时刻的 UI。

> 组件名称必须以大写字母开头。React 会将以小写字母开头的组件视为原生 DOM 标签。例如，
>
> `<div/> `代表 HTML 的 div 标签，而`<Welcome/>` 则代表一个组件，并且需在作用域内使用 Welcome。

### 受控组件与非受控组件

在学习React过程中，我们必然能够看到受控组件与非受控组件的概念。也许初看官方文档或许的确有些令人迷茫的地方。那么什么是受控组件与非受控组件呢？

 在html元素中，通常能够与用户进行数据交互的就只有表单元素了，而在表单元素中，无论是能够接收用户输入文本数据的`<input/>`元素还是能够让用户进行选择的`<select/>`元素，它的内部都会维护一个变量（在React语境下称为state），这个变量存储着用户交互的数据。而React为了实现数据的双向绑定，必然要将数据保存在自定义的state组件中。这种由React控制表单值的组件就被称为**受控组件**。

而并未将值保存在受React控制的变量中的表单元素，就被称为**非受控组件**。

## 渲染

### 普通渲染

```jsx
import React from "react";
import ReactDOM from "react-dom/client";
import App from "./App";

const root = ReactDOM.createRoot(document.getElementById("root"));
root.render(
    <React.StrictMode>
        <App />
    </React.StrictMode>,
);
```

### Protals

## 组件的数据流

在React中，组件的数据是从上往下流动的，顾名思义，就是数据从父组件流向子组件，这个过程是通过props进行传递的。我们知道React是MVVM的框架，而组件内的数据模型就是通过state定义的。

###  state

[state](https://zh-hans.reactjs.org/docs/state-and-lifecycle.html)也称为状态，根据组件是否存在state可以将组件分为有**状态组件**和**无状态组件**。有状态组件一般指的是类组件，而无状态的组件一般指的是函数组件。但是随着React Hoos的更新，函数组件也可以是有状态的。

在类组件中，构造函数是唯一可以为state赋值的地方。

```javascript
    constructor(props: any) {
        super(props);
        this.state = {
            topList: [],
        };
    }
```

使用state有两个需要注意的地方。

- 不要直接修改state。state`的修改必须通过 ` setState() `函数进行修改，否则组件不会被重新渲染。
 ```javascript
  // 不正确的做法
  this.state.topList = [{ a:  '' b" }];
  
  // 正确做法
  this.setState({
      topList: []
  });
 ```

- state的更新可能是异步的。React可能会把多个setState合并成一个调用。因此当你调用了setState之后，state可能不会立刻更新。

#### 有状态组件和无状态组件的区别

#### 为什么State的更新是异步的 

### props





### 基本使用

### Render Props

## 组件的事件

### 基本使用

### 合成事件

## 组件的生命周期

## 组件实例

## 组件复用

### 高阶组件 （HOC）

## 组件间的通信

### 父子组件的通信

假设我们现在有两个组件，父组件`<Counter/>`和子组件`<Add/>`，下面是父子组件传参的方式。

- 父组件通过Props将参数传递给子组件，然后子组件接收父组件传入的参数。

  ```jsx
  // Counter.js
  import Add from "./Add";
  
  function Counter() {
      let num = 0;
  
      return (
          <div>
              <Add num={num}></Add>
          </div>
      );
  }
  
  //Add.js
  function Add(props) {
      return <span>传入数值：{props.num}</span>;
  }
  ```
- 子组件一般通过回调函数将参数传递给父组件。下面的示例在子组件`<Add/>`中添加计数按钮，按钮每次点击就将传入数值 `+1`，然后将值回传给父组件。为了让变量`num`改变后在父组件中及时将结果渲染出来，把父组件修改为Class组件， 将num放到state中，把`num`变成可响应的，

  ```jsx
  // Counter.js
  import { useState } from "react";
  import Add from "./Add";
  
  function Counter() {
      let [num, setNum] = useState(0);
      const handleChange = (temp) => {
          setNum(temp);
      };
  
      return (
          <div>
              <span>计算结果： {num}</span>
              <Add num={num} onChange={handleChange}></Add>
          </div>
      );
  }
  
  // Add.js
  function Add(props) {
      let num = props.num;
      const handleAdd = () => {
          props.onChange(num + 1);
      };
      return (
          <div>
              <button onClick={handleAdd}>点击 + 1</button>
          </div>
      );
  }
  ```
  

### 兄弟组件的通信

所谓兄弟组件，即处于同一个父组件中子组件。其实从上面父组件的通信，大家基本就能看出，如何进行兄弟组件间的通信：其最方便的方式便是经过父组件，由父组件进行中转，将参数传给其他子组件、调用子组件的方法。

在上面父子组件中的通信示例中，再添加另一个子组件`<Sub/>`，sub组件中添加按钮，每次点击按钮就将传入参数`-1`, 并将计算结果通过回调参数传回父组件。这样子组件`<Add/>`和`<Sub/>`，通过父组件`<Counter/>`实现了`num`变量的共享。

```jsx
// Sub.js
function Sub(props) {
    let num = props.num;

    const onClick = function () {
        num -= 1;
        props.onChange(num);
    };

    return <button onClick={onClick}>点击 - 1</button>;
}
```

### 跨级组件的通信

跨级组件通信指的是相隔多个级别的组件间的通信。它们和父子组件、兄弟组件间的通信不一致的是：组件间嵌套过深、甚至压根处于不同分支上的组件间的通信（页面上的组件通常被组织为一棵组件树），这样就不能简单的通过Props或者回调来通信了。

当组件处于同一个分支的时候，通常使用`Context`进行通信，当组件处于不同分支时，通常使用`Event Bus`通信。当然，Event Bus相对Context要灵活的很多。

#### 使用Context 

Context是一个典型的生产者-消费者（Provider-Consumer）模式。当订阅了Context的消费者的组件，能从组件树中，离自己最近的生产者中获取值。Context的使用包含创建和使用两个部分。我们先介绍Context的API，然后再通过Demo说明如何使用Context。

Context的相关API包含下面几个：

- React.createContext(defaultValue)

  通过调用该API,就可以创建一个Context对象。defaultValue是传入的默认值， 当订阅了Context消费者的组件，没有从树中匹配到生产者时，defaultValue才会生效

  ```jsx
  const Context = React.createContext(defaultValue);
  ```

- Conext.displayName

  Context对象能够设置display属性，React DevTools 使用该字符串来确定 context 要显示的内容。

- Context.Provider

  Provider是Context对象上的生产者组件。使用Provider标签包裹的后代组件都能够访问到Provider组件传入的value。

  ```jsx
  <Context.Provider value={/* 需要传给后代的值 */}>
      <ChildComponent></ChildComponent>
  </Context.Provider>
  ```

1. Provider可以嵌套使用，但是同一个Context的Provider嵌套时，里层的值会覆盖外层的值。
1. Provider能够监听到value值的变化，当value值变化时，它内部的所有消费者组件都会重新渲染。 
1. 其实value传入的值也可以是对象，该对象可以包含一个回调函数，用来更新传入的值。

- Context.Consumer

  Consumer是一个消费者组件，此组件可以让你在[函数式组件](https://zh-hans.reactjs.org/docs/components-and-props.html#function-and-class-components)中可以订阅 context。但是这要求消费

  组件必须把一个函数作为子元素，这个函数接受Provider传入的值, 并返回一个React元素节点

  ```jsx
  function FunComponent() {
      return (
          <Context.Consumer>
              {value => {
                  return <div>{value}</div>;
              }}
          </Context.Consumer>
      );
  }
  ```

- Class.contextType

  contextType是自定义的类组件上的静态属性，可以被赋值为创建的Context对象，这样就可以在类组件内部通过`this.Context`来访问生产者传入的值。

  ```jsx
  class ClazzComponet extends React.Component {
      static contextType = Context;
  
      render() {
          const value = this.context;
          return <div>{value}</div>
      }
  }
  ```

  当然，也可以在类外部赋值。
  
  ```jsx
  ClazzComponet.contextType = Context;
  ```

接下来我们通过一个demo演示Context的使用。

1. 创建Context。

   ```jsx
   // Context.js
   import React from "react";
   
   const CounterContext = React.createContext({
       num: 0,
       handleChange: () => {},
   });
   
   CounterContext.displayName = "CounterContextName";
   
   export default CounterContext;
   ```

2. 在Account组件中添加一个Provider组件，将包含一个num变量及改变num变量的回调函数的对象，作为值传入其包裹的子组件及其后代。

   ```jsx
   import React from "react";
   import Counter from "./Counter";
   import CounterContext from "./Context";
   
   class Account extends React.Component {
       static contentType = CounterContext;
   
       constructor(props) {
           super(props);
   
           this.state = {
               num: 0,
           };
           this.handleChange = this.handleChange.bind(this);
       }
   
       handleChange(num) {
           this.setState({
               num,
           });
       }
   
       render() {
           const provider = {
               num: this.state.num,
               handleChange: this.handleChange,
           };
   
           return (
               <CounterContext.Provider value={provider}>
                   <Counter></Counter>
               </CounterContext.Provider>
           );
       }
   }
   
   export default Account;
   ```

3. 在Counter类组件中，订阅Provider传入的value值，并展示对象值的num变量。

   ```jsx
   import React from "react";
   import Add from "./Add";
   import CounterContext from "./Context";
   
   class Counter extends React.Component<any, any> {
       static contextType = CounterContext;
   
       constructor(props) {
           super(props);
       }
   
       render() {
           const { num } = this.context;
   
           return (
               <div>
                   <span>计算结果： {num}</span>
                   <Add num={num}></Add>
               </div>
           );
       }
   }
   
   export default Counter;
   ```

4. 在Add函数组件中，订阅Provider传入的value值，并通过传入的回调函数，更改值中的num变量。

   ```jsx
   import CounterContext from "./Context";
   
   function Add(props) {
       let num = props.num;
       return (
           <CounterContext.Consumer>
               {(context: any) => {
                   const { handleChange } = context;
   
                   return (
                       <button
                           onClick={() => {
                               handleChange(num + 1);
                           }}
                       >
                           点击 + 1
                       </button>
                   );
               }}
           </CounterContext.Consumer>
       );
   }
   
   export default Add;
   ```

#### 使用Event Bus

## Hook

### Hook API

### Hook如何

## 错误处理

## 测试 

## 性能优化

## 参考文档

[1]: https://medium.com/pulseque/stateful-functional-components-react-hooks-e8d533da0f0e	"ReactHooks"
[2]: https://zh-hans.reactjs.org/docs/faq-state.html	"组件状态"
[3]: https://www.cnblogs.com/makai/p/14238200.html	"react的setState到底是同步还是异步？"
[4]: https://segmentfault.com/a/1190000013040438	"React 中 setState() 为什么是异步的？"

[5]: https://juejin.cn/post/6858276396968951822	"受控组件与非受控组件"
[6]: https://mp.weixin.qq.com/s/g1q-K5xDTV5nCB6H22L1Zg	"学好这些 React 设计模式，能让你的 React 项目飞起来"

