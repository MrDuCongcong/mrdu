
### 获取url中的query参数

```javascript
function getQuery() {
    const url = decodeURIComponent(window.location.url.replace(/%20/g, '+'));

    const query = {};
    let mark = url.lastIndexOf('?');
    if (mark !== -1) {
        const str = url.substring(mark + 1);
        const pairs = str.split('&');
        pairs.forEach(item => {
            mark = item.indexOf('=');
            if (mark !== -1) {
                const key = item.substring(0, mark);
                const value = item.substring(mark + 1);
                query[key] = value;
            }
        })
    }
    return query;
}
```


### 防抖和节流

防抖和节流是工作中常用的两个工具，但我却常常把它们搞反。它们都是为了在事件被频发触发时，降低处理该事件的函数的执行频率。只是在不同的场景下，使用不同的方式降低函数的执行频率。

- 防抖。 防抖是指函数在事件被触发的n秒后才执行，如果n秒内被再次触发，则重新计时。
  
  例如：当我们需要根据输入框的内容进行搜索时，当输入框的内容改变后就触发搜索。频繁的搜索会降低效率。如果假如防抖，在内容改变的n秒后才进行搜索，就会减少不必要的搜索。
  
    ``` javascript
    function debounce(fn, delay) {
        let timer = null;
        return function () {
            if (timer) {
                clearTimeout(timer);
            }

            const self = this;
            const args = arguments;
            timer = setTimeout(function () {
                fn.apply(self, args);
            }, delay)
        }
    }
    ```

- 节流。 节流是指函数在事件被触发的n秒内执行一次，而不论事件被触发的有多频繁。

  例如：当我们需要在滚动条被拖动时，需要实时判断滚动条的位置，当滚动条距离底部一定距离时请求下一页数据。如果判断滚动条位置的函数被频繁调用则会造成性能损耗，最佳做法是每隔n毫秒进行一次判断。

    ```javascript
    function throttle(fn, delay) {
        let timer = null;
        return function() {
            if (timer) {
                return;
            }
            const self = this;
            const args = arguments;
            timer = setTimeout(function() {
                fn.apply(self, args);
            }, delay);
        }
    }
    ```
  
可以看到无论是防抖函数还是节流函数，都是一个高阶函数，当我们传入一个时间处理函数fn和延迟时间后，返回一个新的函数，也就是说真正执行事件处理函数的是返回的这个函数。被返回的函数内部保存this，然后通过apply绑定fn的this指向。

### 深拷贝

因为对象是一个引用类型的值，如果一个对象被多处使用，当我们改变这个对象属性的值的时候，可能导致其他使用该对象的代码的异常。因此使用深拷贝是避免因引用导致的bug。

1. 实现深拷贝最简单的方式是序列化。这种方式虽然简单，但缺点也很明显：由于JSON数据格式是为了进行跨平台交换的，独立于语言和平台，因此像`Date`类型会调用内置的`toJSON()`转换为字符串处理；像`undefinde`、`symbol`、函数值转换时，如果是数组中，会被处理成`null`值，如果作为对像的属性值则会被忽略。当然还包括其他情况。
   
    ```javascript
    function  cloneDeep(val) {
        return JSON.parse(JSON.stringify(val));
    }
    ```

2. 通过`Object.assign`实现简单深拷贝。这种拷贝方式的缺点：只能拷贝对象，并且拷贝的对象的属性必须是原始数据类型。
    
    ```javascript
    function cloneDeep(val) {
        return Object.assign({}, val);
    }
    ```
   
3. 递归实现深拷贝。





