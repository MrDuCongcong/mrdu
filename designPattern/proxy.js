/**
 * 代理模式
 * 代理模式是对另一个对象的包装，以便控制客户该对象的访问。
 * 代理模式有多种使用场景：例如保护代理、虚拟代理、缓存代理等。
 * 保护代理：代理可以控制客户对象的访问，只有满足要求时才将请求传递给服务对象。
 * 虚拟代理：当一个对象对系统的资源消耗比较大的时候，可以延迟它的初始化。
 *     无需在程序在初始化的时候就创建它，可以将它的初始化延迟到真正有需要的时候。
 * 缓存代理：为开销大的运算提供缓存，以减少计算或者网络延时。
 * 智能引用代理：计算一个对象被应用的次数，如果没有被引用则销毁该对象。这种代理
 *    通常用在虚拟机的GC(垃圾回收)中。通过引用计数法来判断当前对象所占用的空间是否
 *    可以被回收。
 * 记录日志请求：当我们需要保存服务对象的请求纪律时可以用到。
 * 
 * 当然，其实代理模式还有更多的使用场景，比如同步代理、复杂隐藏代理等。但是我想对于前端来说，
 * 我们可能并不一定会有相应的使用场景。
 */

 /*------------------------------------保护代理------------------------------------------- */

/*-------------------------------------缓存代理------------------------------------------ */

function compute() {
    let result = 0;
    for (let i = 0; i < arguments.length; i +=1) {
        result += arguments[i];
    }
    return result;
}

const  proxyCompute = (function() {
    let cache = {};
    return function() {
        let list = Array.prototype.slice.call(arguments);
        let key = list.join(',');
        if (key in cache) {
            console.log('使用缓存', cache);
            return cache[key];
        } 
        console.log('计算值', cache);
        return cache[key] = compute(...list);
    }
})();

let result1 = proxyCompute(1, 2, 3, 4);
let result2 = proxyCompute(1, 2, 3, 4);
console.log(result1, result2);

/*-------------------------------------虚拟代理------------------------------------------ */

